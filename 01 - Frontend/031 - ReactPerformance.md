## prevent unnecessary re-renders in React

1. **`React.memo()`:** This Higher-Order Component (HOC) memoizes a functional component, preventing it from re-rendering if its props have not shallowly changed. It's ideal for "pure" functional components that render the same output for the same props.
2. **`useCallback()` Hook:** Memoizes a callback function, ensuring its reference remains stable across re-renders unless its dependencies change. This is crucial when passing functions as props to `React.memo`'d child components.
3. **`useMemo()` Hook:** Memoizes a computed value, preventing re-calculation on every render unless its dependencies change. Use it for computationally expensive calculations or to stabilize object/array references passed as props to memoized children.
4. **State Colocation / Lifting State Down:** Store state as close as possible to the components that actually use or modify it, minimizing the scope of re-renders. This prevents parent components from re-rendering and forcing re-renders of unrelated children.
5. **Optimizing Context API Usage:** Split large contexts into smaller, more granular ones, and memoize the context `value` using `useMemo` to prevent unnecessary re-renders of consumers. Custom hooks can also be used to select specific parts of the context.
6. **Virtualization:** For very long lists, only render the items currently visible in the viewport using libraries like `react-window` or `react-virtualized`. This significantly reduces the number of DOM elements and improves scrolling performance.
7. **Conditional Rendering:** Mount and unmount components based on a condition rather than always rendering them and hiding with CSS. This ensures components are only in the DOM when they are actually needed.
8. **Avoid Inline Object/Array/Function Creation:** Do not create new object, array, or function literals directly within JSX or a functional component's body on every render. This creates new references that will bypass `React.memo` and trigger re-renders.
9. **Immutable State Updates:** Always update state immutably by creating new object/array instances instead of directly modifying existing ones. React relies on reference equality to detect state changes and trigger re-renders.
10. **Proper `key` Prop Usage in Lists:** Provide a stable, unique `key` prop for each item in a list. Incorrect or missing keys can lead to unexpected re-renders, incorrect component state, and performance issues.
11. **ESLint Rules:** Utilize ESLint with React-specific rules (e.g., `exhaustive-deps` for hooks) to catch common mistakes that can lead to unnecessary re-renders.
12. **PureComponent (for Class Components):** For class components, extend `React.PureComponent` instead of `React.Component` to automatically perform a shallow prop and state comparison. This is the class component equivalent of `React.memo`.
13. **Memoizing Selectors (e.g., in Redux):** When using state management libraries like Redux, use selector libraries (e.g., Reselect) to memoize derived data. This ensures that mapStateToProps (or `useSelector`) only returns a new value when the underlying data truly changes, preventing unnecessary component re-renders.