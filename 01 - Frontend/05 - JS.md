<https://codefinity.com/blog/Top-50-Must-Know-JavaScript-Interview-Questions?utm_source=google&utm_medium=cpc&utm_campaign=21413601262&utm_content=&utm_term=&dki=&gad_source=1&gad_campaignid=21409590893&gbraid=0AAAAABTeUgTxeT8-7VDZr1ne8DVLPPqfw&gclid=CjwKCAjw4K3DBhBqEiwAYtG_9LaAWMhov3xuxkINwuJLEeIxG9PLiDgfj8sVvW87VsybQ6C70a-WdBoC8XwQAvD_BwE>

### **Explain hoisting in JavaScript.**

- **Answer:** Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase. However, only the declarations are hoisted, not the initializations. `var` variables are hoisted and initialized with `undefined`, while `let` and `const` are hoisted but not initialized, leading to a `ReferenceError` if accessed before declaration. Function declarations are fully hoisted.

### **What are closures in JavaScript?**

- **Answer:** A closure is a function that retains access to its outer function's scope, even after the outer function has finished executing. This means a closure can access variables from its parent function's scope, its own scope, and the global scope. Closures are useful for creating private variables and maintaining state.
- Obj inner function this to obj(by arr function, but common func in obj also to window), common function this to window
- call, apply, bind can appratenly point the this direction

![image.png](attachment:0f58730f-9b8f-4015-b848-6ad530b87fc8:image.png)

### **Explain the concept of the event loop in JavaScript.**

- **Answer:** The event loop is a fundamental mechanism in JavaScript's asynchronous programming model. It's a continuous loop that checks the message queue for tasks (like callbacks from asynchronous operations or user events). When a task is found, it's moved to the call stack for execution. This allows JavaScript to handle non-blocking operations despite being single-threaded.

![image.png](attachment:4cb28ccd-69ff-4962-88b9-e6092d8dfb49:image.png)

### **What is a Promise? How do Promises help with asynchronous operations?**

- **Answer:** A Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide a more structured and manageable way to handle asynchronous code compared to traditional callbacks (avoiding "callback hell"). They have three states: `pending`, `fulfilled` (resolved successfully), and `rejected` (failed).
- You use `.then()` to handle the fulfilled state and `.catch()` to handle the rejected state, providing a more structured way to manage asynchronous code than just using callbacks.

### differences between **arrow functions** and **regular functions**

| **Aspect** | **Arrow Functions** | **Regular Functions** |
| --- | --- | --- |
| **Syntax** | Uses `=>` (e.g., `(a, b) => a + b`) | Uses `function` keyword (e.g., `function(a, b) { return a + b; }`) |
| **`this` Binding** | Inherits `this` from parent scope (lexical scoping) | Creates its own `this` (dynamic scoping, depends on how it's called) |
| **Constructor Usage** | Cannot be used with `new` (throws error) | Can be used as constructors with `new` |
| **`arguments` Object** | No local `arguments` object (uses parent's) | Has its own `arguments` object |
| **`yield` Support** | Cannot be generator functions (no `yield`) | Can be generator functions (with `function*`) |
| **Method Definition** | Not recommended for object methods (due to `this` issues) | Common for object methods |
| **Shorthand for Single Expressions** | Allows omitting `return` and curly braces (e.g., `x => x * 2`) | Requires `return` keyword and braces for multi-line code |

### **Key Takeaways**

- Use **arrow functions** for concise syntax and when you need to preserve the outer `this` (e.g., callbacks, closures).
- Use **regular functions** when you need dynamic `this` binding, `arguments`, or to create objects via constructors.

### Var let const

- Let: Food for loop
- const: immutable, object property can be changed

| **Feature** | **var** | **let** | **const** |
| --- | --- | --- | --- |
| **Scope** | Function/Global | Block | Block |
| **Hoisting** | Yes (initialized with `undefined`) | Yes (but in TDZ, not initialized) | Yes (but in TDZ, not initialized) |
| **Re-declaration** | Yes | No | No |
| **Re-assignment** | Yes | Yes | No |

### **What is event delegation?**

- **Answer:** Event delegation is a technique where you attach a single event listener to a parent element, rather than attaching listeners to each individual child element. When an event occurs on a child element, it bubbles up to the parent, and the single listener can handle the event for all children. This is more efficient for performance, especially with large lists of elements.

### **What is the Document Object Model (DOM)?**

- **Answer:** The DOM is a programming interface for HTML and XML documents. It represents the structure of a document as a tree of objects, where each node in the tree is an object representing a part of the document (like an element, attribute, or text). The DOM provides methods and properties to access, modify, and manipulate the structure, style, and content of a web page.

### **What is the purpose of `use strict`?**

- **Answer:** `use strict` is a directive that enables strict mode in JavaScript. Strict mode enforces stricter parsing and error handling, preventing certain actions and throwing errors for code that might silently fail or cause issues in non-strict mode. It helps write more secure and maintainable code.

### what is first class function in JavaScript

- **Assign functions to variables:** Store a function in a variable, just like you would a string or a number.
- **Pass functions as arguments:** Send a function as an input to another function (higher-order functions).
- **Return functions from other functions:** Have a function produce another function as its output (closures).
- **Store functions in data structures:** Put functions into arrays, objects, or other data structures.

### Key Difference spread and rest operator

- **Spread (`...`)** **EXPANDS** an iterable/object into its individual parts. It's used for **construction** (creating new arrays/objects) or **passing arguments**.
- **Rest (`...`)** **COLLECTS** individual parts into an array (or object). It's used for **deconstruction** (gathering parameters/destructured values).

a comparison table for the **`call`**, **`apply`**, and **`bind`** methods in JavaScript

| **Aspect** | **`call()`** | **`apply()`** | **`bind()`** |
| --- | --- | --- | --- |
| **Primary Purpose** | Calls a function with a specified `this` value and **individual arguments**. | Calls a function with a specified `this` value and **an array of arguments**. | Creates a **new function** that, when called, has a specified `this` value and **pre-set arguments**. |
| **Syntax** | `func.call(thisArg, arg1, arg2, ...)` | `func.apply(thisArg, [arg1, arg2, ...])` | `const newFunc = func.bind(thisArg, arg1, arg2, ...)` |
| **Immediate Execution** | ✅ Yes (invokes the function immediately). | ✅ Yes (invokes the function immediately). | ❌ No (returns a new function to be called later). |
| **Argument Handling** | Accepts arguments **individually** (separated by commas). | Accepts arguments as a **single array**. | Pre-sets arguments that are **appended to future calls** of the new function. |
| **Use Case Examples** | `javascript<br>const person = { name: 'Alice' };<br>function greet(msg) {<br>  console.log(`${msg}, ${this.name}`);<br>}<br>greet.call(person, 'Hello'); // "Hello, Alice"<br>` | `javascript<br>const nums = [5, 3, 8];<br>Math.max.apply(null, nums); // 8<br>` | `javascript<br>const person = { name: 'Bob' };<br>function greet() {<br>  console.log(`Hello, ${this.name}`);<br>}<br>const greetBob = greet.bind(person);<br>greetBob(); // "Hello, Bob"<br>` |
| **Common Use Cases** | - Invoking a method on a different object.<br>- Borrowing methods from other objects. | - Functions that expect an array of arguments (e.g., `Math.max`).<br>- Working with array-like objects (e.g., `arguments`). | - Creating a function with a fixed `this` value for event handlers.<br>- Partial application (pre-filling arguments). |

**Key Takeaways**

- Use **`call`** or **`apply`** when you want to **immediately execute** a function with a custom `this` context and arguments.
- Use **`call`** when arguments are already available individually, and **`apply`** when you have an array of arguments.
- Use **`bind`** when you need to **create a new function** with a fixed `this` value (e.g., for asynchronous operations or event listeners).

### What are Immediately Invoked Function Expressions (IIFE)?

An IIFE is a JavaScript function that runs as soon as it is defined. It's a common pattern for creating a local scope.

### **What are higher-order functions in JavaScript?**

Higher-order functions are functions that take other functions as arguments or return functions. Examples include map() reduice() filter()

### **prototypal inheritance in JavaScript. How does it differ from classical inheritance?**

Prototypal inheritance in JavaScript involves objects inheriting properties and methods directly from other objects through the prototype chain. It differs from classical inheritance, which involves classes inheriting from other classes.

### **What are some common design patterns used in JavaScript? Provide examples of each.**

Some common design patterns used in JavaScript include the module pattern, singleton pattern, factory pattern, observer pattern, and pub/sub pattern.
