### 1. What is TypeScript and how does it differ from JavaScript?

TypeScript is a **superset of JavaScript**, which means any valid JavaScript code is also valid TypeScript code. The primary difference is that TypeScript adds **static typing** to the language. This allows developers to declare types for variables, function parameters, and return values.

**Key Differences:**

- **Static Typing:** TypeScript has optional static typing, while JavaScript is dynamically typed. This helps in catching errors during development rather than at runtime.
- **Compilation:** TypeScript code needs to be compiled into JavaScript before it can be executed in a browser or Node.js environment.
- **Features:** TypeScript includes features from the latest ECMAScript standards and additional features like interfaces, enums, generics, and access modifiers that are not present in standard JavaScript.

### 2. What are the basic data types in TypeScript?

TypeScript has the same basic data types as JavaScript, with the addition of a few extra ones. The core types are:

- **`number`**: For all numeric values (integers and floating-point).
- **`string`**: For textual data.
- **`boolean`**: For `true` or `false` values.
- **`null`**: Represents an intentional absence of an object value.
- **`undefined`**: Represents a variable that has been declared but not assigned a value.
- **`any`**: A dynamic type that can hold any type of value. It's used to opt-out of type checking.
- **`void`**: Used as a return type for functions that do not return a value.
- **`never`**: Represents a value that will never occur. For example, a function that always throws an error.
- **`unknown`**: A type-safe counterpart to `any`. You must perform some form of type checking before you can use a variable of type `unknown`.

### 3. What are Interfaces in TypeScript?

An **interface** is a way to define a contract for an object's shape. It specifies the properties and methods that an object must have. Interfaces are a key feature of TypeScript for enforcing a certain structure on classes or objects.

TypeScript

`interface Person {
  firstName: string;
  lastName: string;
  age?: number; // Optional property
}

function greet(person: Person) {
  return `Hello, ${person.firstName} ${person.lastName}`;
}`

### 4. What are Generics in TypeScript?

**Generics** allow you to write reusable and flexible components, functions, and classes that can work with a variety of data types. This is achieved by creating a "type variable" that will be replaced with a specific type when the component is used.

TypeScript

`function identity<T>(arg: T): T {
  return arg;
}

let output = identity<string>("myString");
let anotherOutput = identity<number>(123);`

### 5. What are Decorators in TypeScript?

**Decorators** are a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter. Decorators use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration. They are commonly used in frameworks like Angular for metadata.

### 6. What are the access modifiers in TypeScript?

TypeScript provides three access modifiers to control the visibility of class members:

- **`public`**: (Default) Members are accessible from anywhere.
- **`private`**: Members are only accessible from within the class they are declared in.
- **`protected`**: Members are accessible from within the class they are declared in and from any subclasses that inherit from it.

### 7. What is the difference between `interface` and `type`?

Both `interface` and `type` can be used to define the shape of an object. However, there are some key differences:

- **Declaration Merging:** Interfaces can be defined multiple times and will be merged into a single interface. `type` aliases cannot.
- **Extending:** `interface` can extend other interfaces using the `extends` keyword. `type` can achieve a similar result using intersections (`&`).
- **Primitives:** `type` can be used to create aliases for primitive types (e.g., `type MyString = string;`), whereas interfaces are primarily for object shapes.

Generally, use `interface` for defining object shapes and `type` for creating aliases for unions or tuples.

### 8. What is the `?` operator in TypeScript?

The `?` operator is used for **optional properties** in interfaces and optional parameters in functions. It signifies that the property or parameter may or may not be present.

TypeScript

`interface Car {
  make: string;
  model?: string; // model is optional
}`

### 9. What is Type Assertion in TypeScript?

Type assertion is a way to tell the compiler what the type of a variable is, even if it can't be inferred. It's like a type cast in other languages but doesn't perform any special checking or restructuring of data.

TypeScript

`let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;`

### 10. What is the `tsconfig.json` file?

The `tsconfig.json` file is the configuration file for a TypeScript project. It specifies the root files and the compiler options required to compile the project. This file allows you to customize how the TypeScript compiler behaves.

## **11. Why do you prefer TypeScript over JavaScript for backend development, especially in larger projects or teams â€“ and what are the key benefits you've experienced?**

I strongly prefer TypeScript over JavaScript for backend development, and my experience on large-scale PaaS and SaaS projects has consistently reinforced this preference62. I see you use it as a core technology, and I am highly proficient with it63. The key benefits I've experienced are:

1. **Static Type-Checking and Error Prevention:** The single biggest benefit is catching errors during development, not in production. With TypeScript, type mismatches, null pointer errors, and incorrect function arguments are flagged by the compiler instantly. This is invaluable on the backend, where a single runtime error could impact data integrity or bring down a critical service.
2. **Improved Code Quality and Maintainability:** Types act as a form of documentation. When I return to a piece of code months later, or when a new team member is onboarding, the type definitions for functions, APIs, and data models make the codebase far easier to understand, refactor, and extend safely. This was critical in my work developing large platforms used by thousands of users64.
3. **Enhanced Developer Experience and Tooling:** The rich intellisense, autocompletion, and refactoring capabilities provided by IDEs for TypeScript are a massive productivity booster. It makes navigating large, complex codebases much faster and more intuitive.
4. **Safer Collaboration in Teams:** In a team environment, TypeScript enforces a contract between different parts of the application and between different developers. When one developer changes a data structure or API signature, the TypeScript compiler immediately alerts other developers whose code is now incompatible, preventing integration issues down the line.

---

## **12. What are some advanced TypeScript features you've used to improve code quality, maintainability, or developer experience (e.g., conditional types, utility types etc)?**

Yes, I frequently use advanced TypeScript features to write cleaner, more robust, and reusable code. Here are a few examples:

- **Utility Types:** I use these constantly. For example, when defining a DTO (Data Transfer Object) for an API endpoint that creates a user, I might use `Omit<User, 'id' | 'createdAt'>` to derive the creation DTO from the main `User` type. This prevents code duplication and ensures that if the `User` type changes, our DTOs are updated accordingly. Similarly, I use `Partial<T>` for update endpoints where any subset of fields can be modified.
- **Generics:** I rely on generics heavily to create reusable and type-safe functions and components. For instance, I've built generic API fetching functions that can be used across the application. You can pass the expected response type as a generic parameter, like `fetchData<User[]>('/api/users')`, ensuring the returned data is correctly typed without needing to write a separate function for every endpoint. This was central to building reusable UI libraries in a previous role65.
- **Conditional Types:** I've used conditional types to create more dynamic and flexible type definitions. For instance, you can create a type that resolves to one shape or another based on a property of the input type. This is useful for creating highly dynamic functions where the return type depends on the specific arguments passed in.
- **`zod` for Runtime Validation:** While not a TypeScript feature itself, I use libraries like `zod` to bridge the gap between TypeScript's compile-time types and runtime validation. I define a `zod` schema to validate incoming API request bodies and can then use `zod.infer<typeof mySchema>` to automatically generate a static TypeScript type from that schema66. This ensures that my data is valid at runtime and correctly typed at compile time, all from a single source of truth.
